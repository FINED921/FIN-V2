local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TextChatService = game:GetService("TextChatService")

local StaminaSettings = {
    StaminaLoss = 10,
    StaminaGain = 25,
    InfiniteGain = 9999
}

-- å£°æ˜æ‰€æœ‰çº¿ç¨‹æ§åˆ¶å˜é‡
local teleportMedkitThread, teleportColaThread, medkitThread, colaThread
local autoTeleportMedkitEnabled, autoTeleportColaEnabled, autoMedkitEnabled, autoColaEnabled

WindUI:Popup({
    Title = "æ¬¢è¿ä½¿ç”¨FINè„šæœ¬",
    Icon = "sparkles",
    Content = "å°Šæ•¬çš„FINç”¨æˆ·ğŸ‘‘,ç¥ä½ å¤©å¤©å¼€å¿ƒ",
    Buttons = {
        {
            Title = "å¯åŠ¨",
            Icon = "arrow-right",
            Variant = "Primary",
            Callback = function() 
                print("å¯åŠ¨è¢«é—å¼ƒ")
                -- åˆ›å»ºä¸»çª—å£
                createMainWindow()
            end
        }
    }
})

function createMainWindow()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hum = Character:WaitForChild("HumanoidRootPart")
    local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

    local Window = WindUI:CreateWindow({
        Title = "FIN | è¢«é—å¼ƒ",
        Icon = "rbxassetid://129260712070622",
        IconThemed = true,
        Author = "ä½œè€…:é‘«æ™´",
        Folder = "CloudHub",
        Size = UDim2.fromOffset(300, 270),
        Transparent = true,
        Theme = "Dark",
        User = {
            Enabled = true,
            Callback = function() print("clicked") end,
            Anonymous = false
        },
        SideBarWidth = 200,
        ScrollBarEnabled = true,
    })

    Window:Tag({
        Title = "v1.3.4",
        Color = Color3.fromHex("#30ff6a")
    })
    Window:Tag({
        Title = "æµ‹è¯•ç‰ˆ", 
        Color = Color3.fromHex("#315dff")
    })
    local TimeTag = Window:Tag({
        Title = "æŒç»­æ›´æ–°",
        Color = Color3.fromHex("#000000")
    })

    Window:EditOpenButton({
        Title = "FIN | è¢«é—å¼ƒ",
        Icon = "star",
        CornerRadius = UDim.new(0,16),
        StrokeThickness = 2,
        Color = ColorSequence.new(
            Color3.fromHex("FF0F7B"), 
            Color3.fromHex("F89B29")
        ),
        Draggable = true,
    })

    local Tab = Window:Tab({
        Title = "åŸºç¡€åŠŸèƒ½",
        Icon = "drama",
        Locked = false,
    })

    local Toggle = Tab:Toggle({
        Title = "æ˜¾ç¤ºå±€å†…èŠå¤©æ¡†",
        Desc = "FIN",
        Locked = false,
        Callback = function(state)
            if TextChatService:FindFirstChild("ChatWindowConfiguration") then
                TextChatService.ChatWindowConfiguration.Enabled = state
            end
        end
    })

    local Tab2 = Window:Tab({
        Title = "ä½“åŠ›æ¶ˆè€—",
        Icon = "drama",
        Locked = false,
    })

    local function GetSprintingModule()
        if ReplicatedStorage:FindFirstChild("Systems") and
           ReplicatedStorage.Systems:FindFirstChild("Character") and
           ReplicatedStorage.Systems.Character:FindFirstChild("Game") and
           ReplicatedStorage.Systems.Character.Game:FindFirstChild("Sprinting") then
            return require(ReplicatedStorage.Systems.Character.Game.Sprinting)
        end
        return nil
    end

    local bai = {Spr = false}
    local connection

    local Toggle2 = Tab2:Toggle({
        Title = "æ— é™ä½“åŠ›",
        Desc = "FIN",
        Locked = false,
        Callback = function(state)
            bai.Spr = state
            local Sprinting = GetSprintingModule()
            
            if not Sprinting then
                warn("æ— æ³•æ‰¾åˆ°ä½“åŠ›æ¨¡å—!")
                return
            end

            if state then
                Sprinting.StaminaLoss = 0
                Sprinting.StaminaGain = StaminaSettings.InfiniteGain or 9999

                if connection then connection:Disconnect() end
                connection = RunService.Heartbeat:Connect(function()
                    if not bai.Spr then 
                        connection:Disconnect()
                        return 
                    end
                    Sprinting.StaminaLoss = 0
                    Sprinting.StaminaGain = StaminaSettings.InfiniteGain or 9999
                end)
            else
                Sprinting.StaminaLoss = StaminaSettings.StaminaLoss or 10
                Sprinting.StaminaGain = StaminaSettings.StaminaGain or 25

                if connection then
                    connection:Disconnect()
                    connection = nil
                end
            end
        end
    })

    local Tab3 = Window:Tab({
        Title = "è‡ªåŠ¨æ”¶å–ç‰©å“",
        Icon = "drama",
        Locked = false,
    })

    local Toggle3 = Tab3:Toggle({
        Title = "åŒ»ç–—åŒ…ä¼ é€ä¸”è·å–",
        Desc = "FIN",
        Locked = false,
        Callback = function(state)
            autoTeleportMedkitEnabled = state
            
            if autoTeleportMedkitEnabled then
                teleportMedkitThread = task.spawn(function()
                    while autoTeleportMedkitEnabled and task.wait(0.5) do
                        local character = game.Players.LocalPlayer.Character
                        if character and character:FindFirstChild("HumanoidRootPart") then
                            local humanoidRootPart = character.HumanoidRootPart
                            
                            local medkit = workspace:FindFirstChild("Map", true)
                            if medkit then
                                medkit = medkit:FindFirstChild("Ingame", true)
                                if medkit then
                                    medkit = medkit:FindFirstChild("Medkit", true)
                                    if medkit then
                                        local itemRoot = medkit:FindFirstChild("ItemRoot", true)
                                        if itemRoot then
                                            itemRoot.CFrame = humanoidRootPart.CFrame + humanoidRootPart.CFrame.LookVector * 3
                                            
                                            local prompt = itemRoot:FindFirstChild("ProximityPrompt", true)
                                            if prompt then
                                                fireproximityprompt(prompt)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
            elseif teleportMedkitThread then
                task.cancel(teleportMedkitThread)
                teleportMedkitThread = nil
            end
        end
    })

    local Toggle4 = Tab3:Toggle({
        Title = "å¯ä¹ç½ä¼ é€ä¸”è·å–",
        Desc = "FIN",
        Locked = false,
        Callback = function(state)
            autoTeleportColaEnabled = state
            
            if autoTeleportColaEnabled then
                teleportColaThread = task.spawn(function()
                    while autoTeleportColaEnabled and task.wait(0.5) do
                        local character = game.Players.LocalPlayer.Character
                        if character and character:FindFirstChild("HumanoidRootPart") then
                            local humanoidRootPart = character.HumanoidRootPart
                            
                            local cola = workspace:FindFirstChild("Map", true)
                            if cola then
                                cola = cola:FindFirstChild("Ingame", true)
                                if cola then
                                    cola = cola:FindFirstChild("BloxyCola", true)
                                    if cola then
                                        local itemRoot = cola:FindFirstChild("ItemRoot", true)
                                        if itemRoot then
                                            itemRoot.CFrame = humanoidRootPart.CFrame + humanoidRootPart.CFrame.LookVector * 3
                                            
                                            local prompt = itemRoot:FindFirstChild("ProximityPrompt", true)
                                            if prompt then
                                                fireproximityprompt(prompt)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
            elseif teleportColaThread then
                task.cancel(teleportColaThread)
                teleportColaThread = nil
            end
        end
    })

    local Toggle5 = Tab3:Toggle({
        Title = "è‡ªåŠ¨äº’åŠ¨åŒ»ç–—åŒ…",
        Desc = "ä¸å…³ä¸Šæ— æ³•ä¸¢å¼ƒğŸ’€",
        Locked = false,
        Callback = function(state)
            autoMedkitEnabled = state
            
            if autoMedkitEnabled then
                medkitThread = task.spawn(function()
                    while autoMedkitEnabled and task.wait(0.5) do
                        local medkit = workspace:FindFirstChild("Map", true)
                        if medkit then
                            medkit = medkit:FindFirstChild("Ingame", true)
                            if medkit then
                                medkit = medkit:FindFirstChild("Medkit", true)
                                if medkit then
                                    local itemRoot = medkit:FindFirstChild("ItemRoot", true)
                                    if itemRoot then
                                        local prompt = itemRoot:FindFirstChild("ProximityPrompt", true)
                                        if prompt then
                                            fireproximityprompt(prompt)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
            elseif medkitThread then
                task.cancel(medkitThread)
                medkitThread = nil
            end
        end
    })

    local Toggle6 = Tab3:Toggle({
        Title = "è‡ªåŠ¨äº’åŠ¨å¯ä¹ç½",
        Desc = "ä¸å…³ä¸Šæ— æ³•ä¸¢å¼ƒğŸ’€",
        Locked = false,
        Callback = function(state)
            autoColaEnabled = state
            
            if autoColaEnabled then
                colaThread = task.spawn(function()
                    while autoColaEnabled and task.wait(0.5) do
                        local cola = workspace:FindFirstChild("Map", true)
                        if cola then
                            cola = cola:FindFirstChild("Ingame", true)
                            if cola then
                                cola = cola:FindFirstChild("BloxyCola", true)
                                if cola then
                                    local itemRoot = cola:FindFirstChild("ItemRoot", true)
                                    if itemRoot then
                                        local prompt = itemRoot:FindFirstChild("ProximityPrompt", true)
                                        if prompt then
                                            fireproximityprompt(prompt)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
            elseif colaThread then
                task.cancel(colaThread)
                colaThread = nil
            end
        end
    })

    local Tab4 = Window:Tab({
        Title = "ä¿®å‘åŠ¨æœº",
        Icon = "drama",
        Locked = false,
    })

    local Toggle7 = Tab4:Toggle({
        Title = "è‡ªåŠ¨ä¿®æœº",
        Desc = "FIN",
        Locked = false,
        Callback = function(state)
            _G.BTE = state
            _G.REP = _G.REP or 1.80

            local function RepairGenerators()
                local map = workspace:FindFirstChild("Map")
                local ingame = map and map:FindFirstChild("Ingame")
                local currentMap = ingame and ingame:FindFirstChild("Map")

                if currentMap then
                    for _, obj in ipairs(currentMap:GetChildren()) do
                        if obj.Name == "Generator" and obj:FindFirstChild("Progress") and obj.Progress.Value < 100 then
                            local remote = obj:FindFirstChild("Remotes") and obj.Remotes:FindFirstChild("RE")
                            if remote then
                                remote:FireServer()
                            end
                        end
                    end
                end
            end

            if state then
                task.spawn(function()
                    while _G.BTE do
                        RepairGenerators()
                        task.wait(_G.REP)
                    end
                end)
            end
        end
    })
end

-- åˆå§‹åŒ–è®¾ç½®
local DistanceSettings = {
    ShowSurvivors = true,
    ShowKillers = true,
    SurvivorColor = Color3.fromRGB(0, 191, 255), -- é»˜è®¤å¹¸å­˜è€…è“è‰²
    KillerColor = Color3.fromRGB(255, 0, 0),     -- é»˜è®¤æ€æ‰‹çº¢è‰²
    TextSize = 14
}

-- è·ç¦»æ˜¾ç¤ºåŠŸèƒ½
local function updateDistanceDisplay()
    -- å…ˆå…³é—­ç°æœ‰è¿æ¥
    if getgenv().distanceUnderFeetConnection then
        getgenv().distanceUnderFeetConnection:Disconnect()
    end
    
    if getgenv().characterRemovedConnection then
        getgenv().characterRemovedConnection:Disconnect()
    end
    
    -- å¦‚æœä¸¤ä¸ªéƒ½å…³é—­åˆ™å®Œå…¨ç¦ç”¨
    if not DistanceSettings.ShowSurvivors and not DistanceSettings.ShowKillers then
        if getgenv().distanceUnderFeetLabels then
            for _, data in pairs(getgenv().distanceUnderFeetLabels) do
                pcall(function() data.label:Remove() end)
            end
            getgenv().distanceUnderFeetLabels = nil
        end
        return
    end
    
    -- åˆå§‹åŒ–å˜é‡
    local players = game:GetService("Players")
    local runService = game:GetService("RunService")
    local localPlayer = players.LocalPlayer
    local camera = workspace.CurrentCamera
    
    -- å­˜å‚¨æ‰€æœ‰è·ç¦»æ ‡ç­¾
    getgenv().distanceUnderFeetLabels = getgenv().distanceUnderFeetLabels or {}
    
    -- ä¸»å¾ªç¯
    getgenv().distanceUnderFeetConnection = runService.RenderStepped:Connect(function()
        local localChar = localPlayer.Character
        if not localChar or not localChar:FindFirstChild("HumanoidRootPart") then return end
        
        local localPos = localChar.HumanoidRootPart.Position
        
        -- å¤„ç†å¹¸å­˜è€…
        if DistanceSettings.ShowSurvivors then
            local survivors = workspace.Players:FindFirstChild("Survivors")
            if survivors then
                for _, survivor in ipairs(survivors:GetChildren()) do
                    if survivor:IsA("Model") and survivor ~= localChar then
                        local hrp = survivor:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            if not getgenv().distanceUnderFeetLabels[survivor] then
                                getgenv().distanceUnderFeetLabels[survivor] = {
                                    label = Drawing.new("Text"),
                                    type = "Survivor"
                                }
                                local label = getgenv().distanceUnderFeetLabels[survivor].label
                                label.Size = DistanceSettings.TextSize
                                label.Center = true
                                label.Outline = true
                                label.Font = 2
                            end
                            
                            local data = getgenv().distanceUnderFeetLabels[survivor]
                            local distance = math.floor((hrp.Position - localPos).Magnitude)
                            local screenPos, onScreen = camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0))
                            
                            if onScreen then
                                data.label.Position = Vector2.new(screenPos.X, screenPos.Y)
                                data.label.Text = tostring(distance) .. "m"
                                data.label.Color = DistanceSettings.SurvivorColor
                                data.label.Visible = true
                            else
                                data.label.Visible = false
                            end
                        end
                    end
                end
            end
        else
            -- éšè—æ‰€æœ‰å¹¸å­˜è€…æ ‡ç­¾
            for model, data in pairs(getgenv().distanceUnderFeetLabels or {}) do
                if data.type == "Survivor" then
                    data.label.Visible = false
                end
            end
        end
        
        -- å¤„ç†æ€æ‰‹
        if DistanceSettings.ShowKillers then
            local killers = workspace.Players:FindFirstChild("Killers")
            if killers then
                for _, killer in ipairs(killers:GetChildren()) do
                    if killer:IsA("Model") then
                        local hrp = killer:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            if not getgenv().distanceUnderFeetLabels[killer] then
                                getgenv().distanceUnderFeetLabels[killer] = {
                                    label = Drawing.new("Text"),
                                    type = "Killer"
                                }
                                local label = getgenv().distanceUnderFeetLabels[killer].label
                                label.Size = DistanceSettings.TextSize
                                label.Center = true
                                label.Outline = true
                                label.Font = 2
                            end
                            
                            local data = getgenv().distanceUnderFeetLabels[killer]
                            local distance = math.floor((hrp.Position - localPos).Magnitude)
                            local screenPos, onScreen = camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0))
                            
                            if onScreen then
                                data.label.Position = Vector2.new(screenPos.X, screenPos.Y)
                                data.label.Text = tostring(distance) .. "m"
                                data.label.Color = DistanceSettings.KillerColor
                                data.label.Visible = true
                            else
                                data.label.Visible = false
                            end
                        end
                    end
                end
            end
        else
            -- éšè—æ‰€æœ‰æ€æ‰‹æ ‡ç­¾
            for model, data in pairs(getgenv().distanceUnderFeetLabels or {}) do
                if data.type == "Killer" then
                    data.label.Visible = false
                end
            end
        end
    end)
    
    -- ç›‘å¬è§’è‰²ç§»é™¤
    getgenv().characterRemovedConnection = workspace.Players.DescendantRemoving:Connect(function(descendant)
        if descendant:IsA("Model") and getgenv().distanceUnderFeetLabels and getgenv().distanceUnderFeetLabels[descendant] then
            getgenv().distanceUnderFeetLabels[descendant].label:Remove()
            getgenv().distanceUnderFeetLabels[descendant] = nil
        end
    end)
end

-- ä¸»å¼€å…³
Visual:AddToggle("DistanceUnderFeet", {
    Text = "ç»˜åˆ¶è·ç¦»æ€»å¼€å…³",
    Default = false,
    Callback = function(enabled)
        if enabled then
            updateDistanceDisplay()
        else
            -- å®Œå…¨å…³é—­
            if getgenv().distanceUnderFeetConnection then
                getgenv().distanceUnderFeetConnection:Disconnect()
            end
            
            if getgenv().characterRemovedConnection then
                getgenv().characterRemovedConnection:Disconnect()
            end
            
            if getgenv().distanceUnderFeetLabels then
                for _, data in pairs(getgenv().distanceUnderFeetLabels) do
                    pcall(function() data.label:Remove() end)
                end
                getgenv().distanceUnderFeetLabels = nil
            end
        end
    end
})
Visual:AddDivider()  
-- å¹¸å­˜è€…å¼€å…³
Visual:AddToggle("ShowSurvivors", {
    Text = "ç»˜åˆ¶å¹¸å­˜è€…è·ç¦»",
    Default = true,
    Callback = function(enabled)
        DistanceSettings.ShowSurvivors = enabled
        if getgenv().distanceUnderFeetConnection then
            updateDistanceDisplay()
        end
    end
})

-- æ€æ‰‹å¼€å…³
Visual:AddToggle("ShowKillers", {
    Text = "ç»˜åˆ¶æ€æ‰‹è·ç¦»",
    Default = true,
    Callback = function(enabled)
        DistanceSettings.ShowKillers = enabled
        if getgenv().distanceUnderFeetConnection then
            updateDistanceDisplay()
        end
    end
})

-- é¢œè‰²è®¾ç½®
Visual:AddDropdown("SurvivorColor", {
    Values = {"è“è‰²", "ç»¿è‰²", "é»„è‰²", "ç´«è‰²", "é’è‰²"},
    Default = 1,
    Text = "å¹¸å­˜è€…é¢œè‰²",
    Callback = function(value)
        local colorMap = {
            ["è“è‰²"] = Color3.fromRGB(0, 191, 255),
            ["ç»¿è‰²"] = Color3.fromRGB(0, 255, 0),
            ["é»„è‰²"] = Color3.fromRGB(255, 255, 0),
            ["ç´«è‰²"] = Color3.fromRGB(128, 0, 128),
            ["é’è‰²"] = Color3.fromRGB(0, 255, 255)
        }
        
        DistanceSettings.SurvivorColor = colorMap[value] or Color3.fromRGB(0, 191, 255)
        if getgenv().distanceUnderFeetLabels then
            for _, data in pairs(getgenv().distanceUnderFeetLabels) do
                if data.type == "Survivor" then
                    data.label.Color = DistanceSettings.SurvivorColor
                end
            end
        end
    end
})

Visual:AddDropdown("KillerColor", {
    Values = {"çº¢è‰²", "æ©™è‰²", "ç²‰è‰²", "ç™½è‰²", "é»‘è‰²"},
    Default = 1,
    Text = "æ€æ‰‹é¢œè‰²",
    Callback = function(value)
        local colorMap = {
            ["çº¢è‰²"] = Color3.fromRGB(255, 0, 0),
            ["æ©™è‰²"] = Color3.fromRGB(255, 165, 0),
            ["ç²‰è‰²"] = Color3.fromRGB(255, 192, 203),
            ["ç™½è‰²"] = Color3.fromRGB(255, 255, 255),
            ["é»‘è‰²"] = Color3.fromRGB(0, 0, 0)
        }
        
        DistanceSettings.KillerColor = colorMap[value] or Color3.fromRGB(255, 0, 0)
        if getgenv().distanceUnderFeetLabels then
            for _, data in pairs(getgenv().distanceUnderFeetLabels) do
                if data.type == "Killer" then
                    data.label.Color = DistanceSettings.KillerColor
                end
            end
        end
    end
})

-- æ–‡å­—å¤§å°è®¾ç½®
Visual:AddSlider("DistanceTextSize", {
    Text = "æ–‡å­—å¤§å°",
    Min = 8,
    Max = 24,
    Default = 14,
    Rounding = 0,
    Callback = function(value)
        DistanceSettings.TextSize = value
        if getgenv().distanceUnderFeetLabels then
            for _, data in pairs(getgenv().distanceUnderFeetLabels) do
                data.label.Size = value
            end
        end
    end
})

Visual:AddDivider()  


local Visual = Tabs.Esp:AddRightGroupbox("é«˜äº®ç»˜åˆ¶")

-- é«˜äº®ç»˜åˆ¶è®¾ç½®
local HighlightSettings = {
    ShowSurvivorHighlights = true,
    ShowKillerHighlights = true,
    FillTransparency = 0.5,
    OutlineTransparency = 0,
    connection = nil,
    highlights = {}  -- å­˜å‚¨æ‰€æœ‰é«˜äº®å¯¹è±¡
}

-- æ›´æ–°é¢œè‰²é¢„è®¾
HighlightSettings.SurvivorColors = {
    ["ç»¿è‰²"] = Color3.fromRGB(0, 255, 0),
    ["ç™½è‰²"] = Color3.fromRGB(255, 255, 255),
    ["ç´«è‰²"] = Color3.fromRGB(128, 0, 128),
    ["é’è‰²"] = Color3.fromRGB(0, 255, 255),
    ["æ©™è‰²"] = Color3.fromRGB(255, 165, 0),
    ["æŸ æª¬ç»¿"] = Color3.fromRGB(173, 255, 47)  -- æ–°å¢æŸ æª¬ç»¿
}

HighlightSettings.KillerColors = {
    ["çº¢è‰²"] = Color3.fromRGB(255, 0, 0),
    ["ç²‰è‰²"] = Color3.fromRGB(255, 105, 180),
    ["é»‘è‰²"] = Color3.fromRGB(0, 0, 0),
    ["è“è‰²"] = Color3.fromRGB(0, 0, 255),
    ["çŒ©çº¢è‰²"] = Color3.fromRGB(220, 20, 60),  -- æ–°å¢çŒ©çº¢è‰²
    ["æè‰²"] = Color3.fromRGB(251, 206, 177)   -- æ–°å¢æè‰²
}

-- è¾¹ç¼˜é¢œè‰²ä½¿ç”¨ä¸å¡«å……é¢œè‰²ç›¸åŒçš„é€‰é¡¹
HighlightSettings.SurvivorOutlineColors = table.clone(HighlightSettings.SurvivorColors)
HighlightSettings.KillerOutlineColors = table.clone(HighlightSettings.KillerColors)

-- é»˜è®¤é¢œè‰²
HighlightSettings.SelectedSurvivorColor = "é’è‰²"
HighlightSettings.SelectedKillerColor = "çº¢è‰²"
HighlightSettings.SelectedSurvivorOutlineColor = "é’è‰²"
HighlightSettings.SelectedKillerOutlineColor = "çº¢è‰²"

-- æ¸…ç†é«˜äº®å¯¹è±¡
local function cleanupHighlights()
    for _, highlight in pairs(HighlightSettings.highlights) do
        if highlight and highlight.Parent then
            highlight:Destroy()
        end
    end
    HighlightSettings.highlights = {}
end

-- æ›´æ–°é«˜äº®æ˜¾ç¤º
local function updateHighlights()
    local players = game:GetService("Players")
    local localPlayer = players.LocalPlayer
    
    -- è·å–å¹¸å­˜è€…å’Œæ€æ‰‹æ–‡ä»¶å¤¹
    local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    
    -- åªå¤„ç†å¹¸å­˜è€…å’Œæ€æ‰‹
    local function processFolder(folder, isKiller)
        if not folder then return end
        
        for _, model in ipairs(folder:GetChildren()) do
            if model:IsA("Model") then
                -- ç¡®å®šé¢œè‰²
                local fillColor = isKiller and HighlightSettings.KillerColors[HighlightSettings.SelectedKillerColor] 
                                          or HighlightSettings.SurvivorColors[HighlightSettings.SelectedSurvivorColor]
                
                local outlineColor = isKiller and HighlightSettings.KillerOutlineColors[HighlightSettings.SelectedKillerOutlineColor] 
                                              or HighlightSettings.SurvivorOutlineColors[HighlightSettings.SelectedSurvivorOutlineColor]
                
                -- æ ¹æ®è®¾ç½®å†³å®šæ˜¯å¦æ˜¾ç¤º
                if (isKiller and HighlightSettings.ShowKillerHighlights) or 
                   (not isKiller and HighlightSettings.ShowSurvivorHighlights) then
                    
                    if not HighlightSettings.highlights[model] then
                        local highlight = Instance.new("Highlight")
                        highlight.Parent = game.CoreGui
                        HighlightSettings.highlights[model] = highlight
                    end
                    
                    local highlight = HighlightSettings.highlights[model]
                    highlight.Adornee = model
                    highlight.FillColor = fillColor
                    highlight.OutlineColor = outlineColor
                    highlight.FillTransparency = HighlightSettings.FillTransparency
                    highlight.OutlineTransparency = HighlightSettings.OutlineTransparency
                elseif HighlightSettings.highlights[model] then
                    HighlightSettings.highlights[model].Adornee = nil
                end
            end
        end
    end
    
    -- å¤„ç†å¹¸å­˜è€…
    processFolder(survivorsFolder, false)
    
    -- å¤„ç†æ€æ‰‹
    processFolder(killersFolder, true)
    
    -- æ¸…ç†ä¸å†å­˜åœ¨çš„æ¨¡å‹çš„é«˜äº®
    for model, highlight in pairs(HighlightSettings.highlights) do
        if not model or not model.Parent then
            highlight:Destroy()
            HighlightSettings.highlights[model] = nil
        end
    end
end

-- ä¸»å¼€å…³
Visual:AddToggle("HighlightToggle", {
    Text = "å¯ç”¨é«˜äº®ç»˜åˆ¶",
    Default = false,
    Callback = function(enabled)
        if enabled then
            -- åˆå§‹åŒ–è¿æ¥
            if not HighlightSettings.connection then
                HighlightSettings.connection = game:GetService("RunService").RenderStepped:Connect(updateHighlights)
            end
        else
            -- å…³é—­è¿æ¥
            if HighlightSettings.connection then
                HighlightSettings.connection:Disconnect()
                HighlightSettings.connection = nil
            end
            -- æ¸…ç†é«˜äº®å¯¹è±¡
            cleanupHighlights()
        end
    end
})

-- å¹¸å­˜è€…å¼€å…³
Visual:AddToggle("ShowSurvivorHighlights", {
    Text = "ç»˜åˆ¶å¹¸å­˜è€…é«˜äº®",
    Default = true,
    Callback = function(enabled)
        HighlightSettings.ShowSurvivorHighlights = enabled
    end
})

-- æ€æ‰‹å¼€å…³
Visual:AddToggle("ShowKillerHighlights", {
    Text = "ç»˜åˆ¶æ€æ‰‹é«˜äº®",
    Default = true,
    Callback = function(enabled)
        HighlightSettings.ShowKillerHighlights = enabled
    end
})

-- å¹¸å­˜è€…å¡«å……é¢œè‰²é€‰æ‹©
Visual:AddDropdown("SurvivorFillColor", {
    Values = {"ç»¿è‰²", "ç™½è‰²", "ç´«è‰²", "é’è‰²", "æ©™è‰²", "æŸ æª¬ç»¿"},
    Default = "é’è‰²",
    Text = "å¹¸å­˜è€…å¡«å……é¢œè‰²",
    Callback = function(value)
        HighlightSettings.SelectedSurvivorColor = value
    end
})

-- æ€æ‰‹å¡«å……é¢œè‰²é€‰æ‹©
Visual:AddDropdown("KillerFillColor", {
    Values = {"çº¢è‰²", "ç²‰è‰²", "é»‘è‰²", "è“è‰²", "çŒ©çº¢è‰²", "æè‰²"},
    Default = "çº¢è‰²",
    Text = "æ€æ‰‹å¡«å……é¢œè‰²",
    Callback = function(value)
        HighlightSettings.SelectedKillerColor = value
    end
})

-- å¹¸å­˜è€…è¾¹ç¼˜é¢œè‰²é€‰æ‹©
Visual:AddDropdown("SurvivorOutlineColor", {
    Values = {"ç»¿è‰²", "ç™½è‰²", "ç´«è‰²", "é’è‰²", "æ©™è‰²", "æŸ æª¬ç»¿"},
    Default = "é’è‰²",
    Text = "å¹¸å­˜è€…è¾¹ç¼˜é¢œè‰²",
    Callback = function(value)
        HighlightSettings.SelectedSurvivorOutlineColor = value
    end
})

-- æ€æ‰‹è¾¹ç¼˜é¢œè‰²é€‰æ‹©
Visual:AddDropdown("KillerOutlineColor", {
    Values = {"çº¢è‰²", "ç²‰è‰²", "é»‘è‰²", "è“è‰²", "çŒ©çº¢è‰²", "æè‰²"},
    Default = "é»‘è‰²",
    Text = "æ€æ‰‹è¾¹ç¼˜é¢œè‰²",
    Callback = function(value)
        HighlightSettings.SelectedKillerOutlineColor = value
    end
})

-- å¡«å……é€æ˜åº¦è°ƒèŠ‚æ»‘å—
Visual:AddSlider("FillTransparency", {
    Text = "å¡«å……é€æ˜åº¦",
    Min = 0,
    Max = 1,
    Default = 0.5,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        HighlightSettings.FillTransparency = value
    end
})

-- è¾¹ç¼˜é€æ˜åº¦è°ƒèŠ‚æ»‘å—
Visual:AddSlider("OutlineTransparency", {
    Text = "è¾¹ç¼˜é€æ˜åº¦",
    Min = 0,
    Max = 1,
    Default = 0,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        HighlightSettings.OutlineTransparency = value
    end
})


local Visual = Tabs.Esp:AddLeftGroupbox("è¡€é‡æ¡ç»˜åˆ¶")

-- è¡€é‡æ¡è®¾ç½®
local HealthBarSettings = {
    ShowSurvivorBars = true,
    ShowKillerBars = true,
    BarWidth = 100,      -- å›ºå®šå®½åº¦
    BarHeight = 5,       -- å›ºå®šé«˜åº¦
    TextSize = 14,       -- å›ºå®šæ–‡å­—å¤§å°
    BarOffset = Vector2.new(0, -30), -- åŸºç¡€åç§»
    TextOffset = Vector2.new(0, -40)  -- æ–‡å­—åç§»
}

-- é¢„è®¾é¢œè‰²æ–¹æ¡ˆï¼ˆä¿®æ”¹åçš„å¹¸å­˜è€…é¢œè‰²ï¼‰
local ColorPresets = {
    Survivor = {
        FullHealth = Color3.fromRGB(0, 255, 255),    -- é’è‰²(æ»¡è¡€)
        HalfHealth = Color3.fromRGB(0, 255, 0),      -- ç»¿è‰²(åŠè¡€)
        LowHealth = Color3.fromRGB(255, 165, 0)      -- æ©™è‰²(ä½è¡€)
    },
    Killer = {
        FullHealth = Color3.fromRGB(255, 0, 0),      -- çº¢è‰²(æ»¡è¡€)
        HalfHealth = Color3.fromRGB(255, 165, 0),    -- æ©™è‰²(åŠè¡€)
        LowHealth = Color3.fromRGB(255, 255, 0)      -- é»„è‰²(ä½è¡€)
    },
    Common = {
        Background = Color3.fromRGB(50, 50, 50),
        Outline = Color3.fromRGB(0, 0, 0),
        Text = Color3.fromRGB(255, 255, 255)        -- ç™½è‰²æ–‡å­—
    }
}

-- å­˜å‚¨æ‰€æœ‰ç»˜åˆ¶å¯¹è±¡
local HealthBarDrawings = {}

-- åˆ›å»ºè¡€é‡æ¡ç»˜åˆ¶å¯¹è±¡
local function createHealthBarDrawing()
    local drawing = {
        background = Drawing.new("Square"),
        bar = Drawing.new("Square"),
        outline = Drawing.new("Square"),
        text = Drawing.new("Text")
    }
    
    -- èƒŒæ™¯è®¾ç½®
    drawing.background.Thickness = 1
    drawing.background.Filled = true
    drawing.background.Color = ColorPresets.Common.Background
    
    -- è¡€é‡æ¡è®¾ç½®
    drawing.bar.Thickness = 1
    drawing.bar.Filled = true
    
    -- è¾¹æ¡†è®¾ç½®
    drawing.outline.Thickness = 2
    drawing.outline.Filled = false
    drawing.outline.Color = ColorPresets.Common.Outline
    
    -- æ–‡å­—è®¾ç½®
    drawing.text.Center = true
    drawing.text.Outline = true
    drawing.text.Font = 2
    drawing.text.Color = ColorPresets.Common.Text
    
    return drawing
end

-- æ ¹æ®è¡€é‡è·å–é¢œè‰²ï¼ˆä¿®æ”¹åçš„é˜ˆå€¼ï¼‰
local function getHealthColor(humanoid, isKiller)
    local healthPercent = (humanoid.Health / humanoid.MaxHealth) * 100
    
    if isKiller then
        if healthPercent > 50 then
            return ColorPresets.Killer.FullHealth
        elseif healthPercent > 25 then
            return ColorPresets.Killer.HalfHealth
        else
            return ColorPresets.Killer.LowHealth
        end
    else
        -- å¹¸å­˜è€…æ–°é¢œè‰²é˜ˆå€¼
        if healthPercent > 75 then
            return ColorPresets.Survivor.FullHealth    -- æ»¡è¡€(75%ä»¥ä¸Š): é’è‰²
        elseif healthPercent > 35 then
            return ColorPresets.Survivor.HalfHealth    -- åŠè¡€(35%-75%): ç»¿è‰²
        else
            return ColorPresets.Survivor.LowHealth     -- ä½è¡€(35%ä»¥ä¸‹): æ©™è‰²
        end
    end
end

-- æ›´æ–°è¡€é‡æ¡ï¼ˆä¼˜åŒ–åä¸æ˜¾ç¤ºè‡ªèº«è¡€æ¡ï¼‰
local function updateHealthBars()
    local camera = workspace.CurrentCamera
    local players = game:GetService("Players")
    local localPlayer = players.LocalPlayer
    
    -- å¤„ç†å¹¸å­˜è€…
    if HealthBarSettings.ShowSurvivorBars then
        local survivors = workspace.Players:FindFirstChild("Survivors")
        if survivors then
            for _, survivor in ipairs(survivors:GetChildren()) do
                if survivor:IsA("Model") and survivor ~= localPlayer.Character then  -- ä¸æ˜¾ç¤ºè‡ªèº«è¡€æ¡
                    local humanoid = survivor:FindFirstChildOfClass("Humanoid")
                    local head = survivor:FindFirstChild("Head")
                    
                    if humanoid and head then
                        -- è·å–æˆ–åˆ›å»ºç»˜åˆ¶å¯¹è±¡
                        if not HealthBarDrawings[survivor] then
                            HealthBarDrawings[survivor] = createHealthBarDrawing()
                        end
                        
                        local drawing = HealthBarDrawings[survivor]
                        local screenPos, onScreen = camera:WorldToViewportPoint(head.Position)
                        
                        if onScreen then
                            -- è®¡ç®—è¡€é‡ç™¾åˆ†æ¯”
                            local healthPercent = math.floor((humanoid.Health / humanoid.MaxHealth) * 100)
                            local healthBarWidth = HealthBarSettings.BarWidth * (healthPercent / 100)
                            
                            -- è®¾ç½®ä½ç½®
                            local barPos = Vector2.new(
                                screenPos.X + HealthBarSettings.BarOffset.X - (HealthBarSettings.BarWidth / 2),
                                screenPos.Y + HealthBarSettings.BarOffset.Y
                            )
                            
                            -- èƒŒæ™¯å’Œè¾¹æ¡†
                            drawing.background.Size = Vector2.new(HealthBarSettings.BarWidth, HealthBarSettings.BarHeight)
                            drawing.background.Position = barPos
                            drawing.background.Visible = true
                            
                            drawing.outline.Size = Vector2.new(HealthBarSettings.BarWidth, HealthBarSettings.BarHeight)
                            drawing.outline.Position = barPos
                            drawing.outline.Visible = true
                            
                            -- è¡€é‡æ¡ï¼ˆä½¿ç”¨æ–°é¢œè‰²æ–¹æ¡ˆï¼‰
                            drawing.bar.Color = getHealthColor(humanoid, false)
                            drawing.bar.Size = Vector2.new(healthBarWidth, HealthBarSettings.BarHeight)
                            drawing.bar.Position = barPos
                            drawing.bar.Visible = true
                            
                            -- æ–‡å­—
                            drawing.text.Text = tostring(healthPercent) .. "%"
                            drawing.text.Size = HealthBarSettings.TextSize
                            drawing.text.Position = Vector2.new(
                                screenPos.X + HealthBarSettings.TextOffset.X,
                                screenPos.Y + HealthBarSettings.TextOffset.Y
                            )
                            drawing.text.Visible = true
                        else
                            -- ä¸åœ¨å±å¹•å†…åˆ™éšè—
                            for _, obj in pairs(drawing) do
                                obj.Visible = false
                            end
                        end
                    end
                end
            end
        end
    end
    
    -- å¤„ç†æ€æ‰‹
    if HealthBarSettings.ShowKillerBars then
        local killers = workspace.Players:FindFirstChild("Killers")
        if killers then
            for _, killer in ipairs(killers:GetChildren()) do
                if killer:IsA("Model") then
                    local humanoid = killer:FindFirstChildOfClass("Humanoid")
                    local head = killer:FindFirstChild("Head")
                    
                    if humanoid and head then
                        -- è·å–æˆ–åˆ›å»ºç»˜åˆ¶å¯¹è±¡
                        if not HealthBarDrawings[killer] then
                            HealthBarDrawings[killer] = createHealthBarDrawing()
                        end
                        
                        local drawing = HealthBarDrawings[killer]
                        local screenPos, onScreen = camera:WorldToViewportPoint(head.Position)
                        
                        if onScreen then
                            -- è®¡ç®—è¡€é‡ç™¾åˆ†æ¯”
                            local healthPercent = math.floor((humanoid.Health / humanoid.MaxHealth) * 100)
                            local healthBarWidth = HealthBarSettings.BarWidth * (healthPercent / 100)
                            
                            -- è®¾ç½®ä½ç½®
                            local barPos = Vector2.new(
                                screenPos.X + HealthBarSettings.BarOffset.X - (HealthBarSettings.BarWidth / 2),
                                screenPos.Y + HealthBarSettings.BarOffset.Y
                            )
                            
                            -- èƒŒæ™¯å’Œè¾¹æ¡†
                            drawing.background.Size = Vector2.new(HealthBarSettings.BarWidth, HealthBarSettings.BarHeight)
                            drawing.background.Position = barPos
                            drawing.background.Visible = true
                            
                            drawing.outline.Size = Vector2.new(HealthBarSettings.BarWidth, HealthBarSettings.BarHeight)
                            drawing.outline.Position = barPos
                            drawing.outline.Visible = true
                            
                            -- è¡€é‡æ¡
                            drawing.bar.Color = getHealthColor(humanoid, true)
                            drawing.bar.Size = Vector2.new(healthBarWidth, HealthBarSettings.BarHeight)
                            drawing.bar.Position = barPos
                            drawing.bar.Visible = true
                            
                            -- æ–‡å­—
                            drawing.text.Text = tostring(healthPercent) .. "%"
                            drawing.text.Size = HealthBarSettings.TextSize
                            drawing.text.Position = Vector2.new(
                                screenPos.X + HealthBarSettings.TextOffset.X,
                                screenPos.Y + HealthBarSettings.TextOffset.Y
                            )
                            drawing.text.Visible = true
                        else
                            -- ä¸åœ¨å±å¹•å†…åˆ™éšè—
                            for _, obj in pairs(drawing) do
                                obj.Visible = false
                            end
                        end
                    end
                end
            end
        end
    end
end

-- æ¸…ç†è¡€é‡æ¡
local function cleanupHealthBars()
    for _, drawing in pairs(HealthBarDrawings) do
        for _, obj in pairs(drawing) do
            if obj then
                obj:Remove()
            end
        end
    end
    HealthBarDrawings = {}
end

-- ä¸»å¼€å…³
Visual:AddToggle("HealthBarsToggle", {
    Text = "å¯ç”¨è¡€é‡æ¡",
    Default = false,
    Callback = function(enabled)
        if enabled then
            -- åˆå§‹åŒ–è¿æ¥
            if not HealthBarSettings.connection then
                HealthBarSettings.connection = game:GetService("RunService").RenderStepped:Connect(updateHealthBars)
            end
            
            -- ç›‘å¬è§’è‰²ç§»é™¤
            if not HealthBarSettings.removedConnection then
                HealthBarSettings.removedConnection = workspace.DescendantRemoving:Connect(function(descendant)
                    if HealthBarDrawings[descendant] then
                        for _, obj in pairs(HealthBarDrawings[descendant]) do
                            obj:Remove()
                        end
                        HealthBarDrawings[descendant] = nil
                    end
                end)
            end
        else
            -- å…³é—­è¿æ¥
            if HealthBarSettings.connection then
                HealthBarSettings.connection:Disconnect()
                HealthBarSettings.connection = nil
            end
            
            if HealthBarSettings.removedConnection then
                HealthBarSettings.removedConnection:Disconnect()
                HealthBarSettings.removedConnection = nil
            end
            
            -- æ¸…ç†ç»˜åˆ¶å¯¹è±¡
            cleanupHealthBars()
        end
    end
})

-- å¹¸å­˜è€…å¼€å…³
Visual:AddToggle("ShowSurvivorBars", {
    Text = "æ˜¾ç¤ºå¹¸å­˜è€…è¡€é‡æ¡",
    Default = true,
    Callback = function(enabled)
        HealthBarSettings.ShowSurvivorBars = enabled
    end
})

-- æ€æ‰‹å¼€å…³
Visual:AddToggle("ShowKillerBars", {
    Text = "æ˜¾ç¤ºæ€æ‰‹è¡€é‡æ¡",
    Default = true,
    Callback = function(enabled)
        HealthBarSettings.ShowKillerBars = enabled
    end
})

-- å¤§å°è®¾ç½®
Visual:AddSlider("BarWidth", {
    Text = "è¡€é‡æ¡å®½åº¦",
    Min = 50,
    Max = 200,
    Default = 100,
    Rounding = 0,
    Callback = function(value)
        HealthBarSettings.BarWidth = value
    end
})

Visual:AddSlider("BarHeight", {
    Text = "è¡€é‡æ¡é«˜åº¦",
    Min = 3,
    Max = 15,
    Default = 5,
    Rounding = 0,
    Callback = function(value)
        HealthBarSettings.BarHeight = value
    end
})

Visual:AddSlider("TextSize", {
    Text = "æ–‡å­—å¤§å°",
    Min = 10,
    Max = 20,
    Default = 14,
    Rounding = 0,
    Callback = function(value)
        HealthBarSettings.TextSize = value
    end
})

-- ä½ç½®è°ƒæ•´
Visual:AddSlider("BarOffsetY", {
    Text = "å‚ç›´åç§»",
    Min = -50,
    Max = 50,
    Default = -30,
    Rounding = 0,
    Callback = function(value)
        HealthBarSettings.BarOffset = Vector2.new(HealthBarSettings.BarOffset.X, value)
        HealthBarSettings.TextOffset = Vector2.new(HealthBarSettings.TextOffset.X, value - 10)
    end
})



local Visual = Tabs.Esp:AddRightGroupbox("3Dæ–¹æ¡†ç»˜åˆ¶")

-- 3Dæ–¹æ¡†ç»˜åˆ¶è®¾ç½®
local Box3DSettings = {
    -- åŸºæœ¬è®¾ç½®
    Enabled = false,
    ShowSurvivorBoxes = true,
    ShowKillerBoxes = true,
    
    -- é¢œè‰²è®¾ç½®
    SurvivorColor = Color3.fromRGB(0, 255, 255), -- é’è‰²
    KillerColor = Color3.fromRGB(255, 0, 0),     -- çº¢è‰²
    UseTeamColor = true,
    
    -- æ ·å¼è®¾ç½®
    Thickness = 1,
    Transparency = 0.7,
    BoxHeightOffset = 0.5,
    
    -- æ¯”ä¾‹è®¾ç½®
    SurvivorBoxScale = 1.0,
    KillerBoxScale = 1.2,
    
    -- å®½åº¦è°ƒèŠ‚
    LeftWidthScale = 1.0,
    RightWidthScale = 1.0,
    
    -- æ·±åº¦è°ƒèŠ‚ (åŠ å¼ºç‰ˆ)
    FrontExtend = 1.0,
    BackExtend = 1.0,
    FrontExtendMultiplier = 1.0,  -- å‰å»¶ä¼¸å€æ•°
    BackExtendMultiplier = 1.0,   -- åå»¶ä¼¸å€æ•°
    
    -- é«˜åº¦è°ƒèŠ‚
    HeadOffset = 1.5,
    FootOffset = 0.2,
    BoxHeightScale = 1.0,         -- æ–¹æ¡†é«˜åº¦æ¯”ä¾‹
    VerticalOffset = 0,           -- å‚ç›´åç§»
    
    -- è¿æ¥çº¿
    connection = nil,
    removedConnection = nil
}

-- å­˜å‚¨æ‰€æœ‰3Dæ–¹æ¡†ç»˜åˆ¶å¯¹è±¡
local Box3DDrawings = {}

-- åˆ›å»º3Dæ–¹æ¡†ç»˜åˆ¶å¯¹è±¡
local function create3DBoxDrawing()
    local drawing = {
        lines = {},
        visible = false
    }
    
    for i = 1, 12 do
        drawing.lines[i] = Drawing.new("Line")
        drawing.lines[i].Thickness = Box3DSettings.Thickness
        drawing.lines[i].Transparency = Box3DSettings.Transparency
        drawing.lines[i].Visible = false
    end
    
    return drawing
end

-- è®¡ç®—æ¨¡å‹çš„3Dè¾¹ç•Œæ¡†ï¼ˆå…¨æ–¹ä½è°ƒèŠ‚ï¼‰
local function calculateModelBoundingBox(model, isKiller)
    local rootPart = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("Torso") or model:FindFirstChild("UpperTorso")
    local head = model:FindFirstChild("Head")
    
    if rootPart then
        local size = rootPart.Size
        local cframe = rootPart.CFrame
        
        -- åº”ç”¨æ¯”ä¾‹è°ƒæ•´
        local scale = isKiller and Box3DSettings.KillerBoxScale or Box3DSettings.SurvivorBoxScale
        size = size * scale
        
        -- è®¡ç®—åŸºç¡€é«˜åº¦å¹¶åº”ç”¨é«˜åº¦æ¯”ä¾‹
        local baseHeight = 5
        if head then
            baseHeight = (head.Position.Y - rootPart.Position.Y) * 2
        end
        local height = (baseHeight + Box3DSettings.HeadOffset + Box3DSettings.FootOffset) * Box3DSettings.BoxHeightScale
        
        -- è°ƒæ•´å·¦å³å®½åº¦
        local leftOffset = (size.X/2) * Box3DSettings.LeftWidthScale
        local rightOffset = (size.X/2) * Box3DSettings.RightWidthScale
        
        -- è°ƒæ•´å‰åå»¶ä¼¸ (åŠ å¼ºç‰ˆ)
        local frontOffset = (size.Z/2) * Box3DSettings.FrontExtend * Box3DSettings.FrontExtendMultiplier
        local backOffset = (size.Z/2) * Box3DSettings.BackExtend * Box3DSettings.BackExtendMultiplier
        
        -- è®¡ç®—æœ€å°å’Œæœ€å¤§ç‚¹
        local min = Vector3.new(
            cframe.Position.X - leftOffset,
            cframe.Position.Y - height/2 + Box3DSettings.FootOffset,
            cframe.Position.Z - backOffset
        )
        
        local max = Vector3.new(
            cframe.Position.X + rightOffset,
            cframe.Position.Y + height/2 + Box3DSettings.HeadOffset,
            cframe.Position.Z + frontOffset
        )
        
        -- åº”ç”¨é«˜åº¦åç§»å’Œå‚ç›´åç§»
        min = Vector3.new(min.X, min.Y + Box3DSettings.BoxHeightOffset + Box3DSettings.VerticalOffset, min.Z)
        max = Vector3.new(max.X, max.Y + Box3DSettings.BoxHeightOffset + Box3DSettings.VerticalOffset, max.Z)
        
        return min, max
    else
        -- å›é€€åˆ°éå†æ‰€æœ‰éƒ¨ä»¶çš„æ–¹æ³•
        local min = Vector3.new(math.huge, math.huge, math.huge)
        local max = Vector3.new(-math.huge, -math.huge, -math.huge)
        
        for _, part in ipairs(model:GetDescendants()) do
            if part:IsA("BasePart") then
                local cframe = part.CFrame
                local size = part.Size
                
                local scale = isKiller and Box3DSettings.KillerBoxScale or Box3DSettings.SurvivorBoxScale
                size = size * scale
                
                -- è°ƒæ•´å·¦å³å®½åº¦
                local leftOffset = (size.X/2) * Box3DSettings.LeftWidthScale
                local rightOffset = (size.X/2) * Box3DSettings.RightWidthScale
                
                -- è°ƒæ•´å‰åå»¶ä¼¸ (åŠ å¼ºç‰ˆ)
                local frontOffset = (size.Z/2) * Box3DSettings.FrontExtend * Box3DSettings.FrontExtendMultiplier
                local backOffset = (size.Z/2) * Box3DSettings.BackExtend * Box3DSettings.BackExtendMultiplier
                
                -- è®¡ç®—é¡¶ç‚¹ï¼ˆè€ƒè™‘å‰åå»¶ä¼¸ï¼‰
                local vertices = {
                    cframe * Vector3.new(rightOffset, (size.Y/2) * Box3DSettings.BoxHeightScale, frontOffset),
                    cframe * Vector3.new(-leftOffset, (size.Y/2) * Box3DSettings.BoxHeightScale, frontOffset),
                    cframe * Vector3.new(rightOffset, (-size.Y/2) * Box3DSettings.BoxHeightScale, frontOffset),
                    cframe * Vector3.new(-leftOffset, (-size.Y/2) * Box3DSettings.BoxHeightScale, frontOffset),
                    cframe * Vector3.new(rightOffset, (size.Y/2) * Box3DSettings.BoxHeightScale, -backOffset),
                    cframe * Vector3.new(-leftOffset, (size.Y/2) * Box3DSettings.BoxHeightScale, -backOffset),
                    cframe * Vector3.new(rightOffset, (-size.Y/2) * Box3DSettings.BoxHeightScale, -backOffset),
                    cframe * Vector3.new(-leftOffset, (-size.Y/2) * Box3DSettings.BoxHeightScale, -backOffset)
                }
                
                -- æ›´æ–°æœ€å°å’Œæœ€å¤§ç‚¹
                for _, vertex in ipairs(vertices) do
                    min = Vector3.new(
                        math.min(min.X, vertex.X),
                        math.min(min.Y, vertex.Y),
                        math.min(min.Z, vertex.Z)
                    )
                    max = Vector3.new(
                        math.max(max.X, vertex.X),
                        math.max(max.Y, vertex.Y),
                        math.max(max.Z, vertex.Z)
                    )
                end
            end
        end
        
        -- åº”ç”¨é«˜åº¦åç§»å’Œå‚ç›´åç§»
        min = Vector3.new(min.X, min.Y + Box3DSettings.BoxHeightOffset + Box3DSettings.VerticalOffset, min.Z)
        max = Vector3.new(max.X, max.Y + Box3DSettings.BoxHeightOffset + Box3DSettings.VerticalOffset, max.Z)
        
        return min, max
    end
end

-- æ›´æ–°å•ä¸ª3Dæ–¹æ¡†
local function updateSingle3DBox(model, drawing, color, isKiller)
    local camera = workspace.CurrentCamera
    local min, max = calculateModelBoundingBox(model, isKiller)
    
    -- è®¡ç®—ç«‹æ–¹ä½“çš„8ä¸ªé¡¶ç‚¹
    local vertices = {
        Vector3.new(max.X, max.Y, max.Z), -- å³ä¸Šå
        Vector3.new(min.X, max.Y, max.Z), -- å·¦ä¸Šå
        Vector3.new(max.X, min.Y, max.Z), -- å³ä¸‹å
        Vector3.new(min.X, min.Y, max.Z), -- å·¦ä¸‹å
        Vector3.new(max.X, max.Y, min.Z), -- å³ä¸Šå‰
        Vector3.new(min.X, max.Y, min.Z), -- å·¦ä¸Šå‰
        Vector3.new(max.X, min.Y, min.Z), -- å³ä¸‹å‰
        Vector3.new(min.X, min.Y, min.Z)  -- å·¦ä¸‹å‰
    }
    
    -- è½¬æ¢é¡¶ç‚¹åˆ°å±å¹•ç©ºé—´
    local screenVertices = {}
    local anyVisible = false
    
    for i, vertex in ipairs(vertices) do
        local screenPos, onScreen = camera:WorldToViewportPoint(vertex)
        screenVertices[i] = Vector2.new(screenPos.X, screenPos.Y)
        if onScreen then anyVisible = true end
    end
    
    -- è®¾ç½®çº¿æ¡å±æ€§
    for _, line in pairs(drawing.lines) do
        line.Color = color
        line.Thickness = Box3DSettings.Thickness
        line.Transparency = Box3DSettings.Transparency
    end
    
    -- ç»˜åˆ¶ç«‹æ–¹ä½“è¾¹çº¿
    if anyVisible then
        -- å‰é¢4æ¡è¾¹
        drawing.lines[1].From = screenVertices[5] drawing.lines[1].To = screenVertices[6] -- ä¸Šé¢å‰
        drawing.lines[2].From = screenVertices[6] drawing.lines[2].To = screenVertices[8] -- å·¦è¾¹å‰
        drawing.lines[3].From = screenVertices[8] drawing.lines[3].To = screenVertices[7] -- ä¸‹é¢å‰
        drawing.lines[4].From = screenVertices[7] drawing.lines[4].To = screenVertices[5] -- å³è¾¹å‰
        
        -- åé¢4æ¡è¾¹
        drawing.lines[5].From = screenVertices[1] drawing.lines[5].To = screenVertices[2] -- ä¸Šé¢å
        drawing.lines[6].From = screenVertices[2] drawing.lines[6].To = screenVertices[4] -- å·¦è¾¹å
        drawing.lines[7].From = screenVertices[4] drawing.lines[7].To = screenVertices[3] -- ä¸‹é¢å
        drawing.lines[8].From = screenVertices[3] drawing.lines[8].To = screenVertices[1] -- å³è¾¹å
        
        -- è¿æ¥å‰åé¢çš„4æ¡è¾¹
        drawing.lines[9].From = screenVertices[1] drawing.lines[9].To = screenVertices[5] -- å³ä¸Š
        drawing.lines[10].From = screenVertices[2] drawing.lines[10].To = screenVertices[6] -- å·¦ä¸Š
        drawing.lines[11].From = screenVertices[3] drawing.lines[11].To = screenVertices[7] -- å³ä¸‹
        drawing.lines[12].From = screenVertices[4] drawing.lines[12].To = screenVertices[8] -- å·¦ä¸‹
        
        -- æ˜¾ç¤ºæ‰€æœ‰çº¿æ¡
        for _, line in pairs(drawing.lines) do
            line.Visible = true
        end
        
        drawing.visible = true
    else
        if drawing.visible then
            for _, line in pairs(drawing.lines) do
                line.Visible = false
            end
            drawing.visible = false
        end
    end
end

-- æ›´æ–°æ‰€æœ‰3Dæ–¹æ¡†
local function update3DBoxes()
    local players = game:GetService("Players")
    local localPlayer = players.LocalPlayer
    local camera = workspace.CurrentCamera
    
    -- å…ˆéšè—æ‰€æœ‰ç°æœ‰çš„æ–¹æ¡†
    for model, drawing in pairs(Box3DDrawings) do
        if not model or not model.Parent then
            -- æ¨¡å‹å·²ä¸å­˜åœ¨ï¼Œæ¸…ç†ç»˜åˆ¶å¯¹è±¡
            for _, line in pairs(drawing.lines) do
                line:Remove()
            end
            Box3DDrawings[model] = nil
        else
            -- æš‚æ—¶éšè—
            for _, line in pairs(drawing.lines) do
                line.Visible = false
            end
            drawing.visible = false
        end
    end
    
    -- å¤„ç†å¹¸å­˜è€…æ–¹æ¡†
    if Box3DSettings.ShowSurvivorBoxes then
        local survivors = workspace:FindFirstChild("Survivors") or workspace.Players:FindFirstChild("Survivors")
        if survivors then
            for _, survivor in ipairs(survivors:GetChildren()) do
                if survivor:IsA("Model") and survivor ~= localPlayer.Character then
                    -- è·å–æˆ–åˆ›å»ºç»˜åˆ¶å¯¹è±¡
                    if not Box3DDrawings[survivor] then
                        Box3DDrawings[survivor] = create3DBoxDrawing()
                    end
                    
                    updateSingle3DBox(survivor, Box3DDrawings[survivor], Box3DSettings.SurvivorColor, false)
                end
            end
        end
        
        -- é¢å¤–æ£€æŸ¥ç©å®¶åˆ—è¡¨ä¸­çš„å¹¸å­˜è€…
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= localPlayer and player.Character and not player.Character:FindFirstChild("IsKiller") then
                if not Box3DDrawings[player.Character] then
                    Box3DDrawings[player.Character] = create3DBoxDrawing()
                end
                
                updateSingle3DBox(player.Character, Box3DDrawings[player.Character], Box3DSettings.SurvivorColor, false)
            end
        end
    end
    
    -- å¤„ç†æ€æ‰‹æ–¹æ¡†
    if Box3DSettings.ShowKillerBoxes then
        local killers = workspace:FindFirstChild("Killers") or workspace.Players:FindFirstChild("Killers")
        if killers then
            for _, killer in ipairs(killers:GetChildren()) do
                if killer:IsA("Model") and killer ~= localPlayer.Character then
                    -- è·å–æˆ–åˆ›å»ºç»˜åˆ¶å¯¹è±¡
                    if not Box3DDrawings[killer] then
                        Box3DDrawings[killer] = create3DBoxDrawing()
                    end
                    
                    updateSingle3DBox(killer, Box3DDrawings[killer], Box3DSettings.KillerColor, true)
                end
            end
        end
        
        -- é¢å¤–æ£€æŸ¥ç©å®¶åˆ—è¡¨ä¸­çš„æ€æ‰‹
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= localPlayer and player.Character and player.Character:FindFirstChild("IsKiller") then
                if not Box3DDrawings[player.Character] then
                    Box3DDrawings[player.Character] = create3DBoxDrawing()
                end
                
                updateSingle3DBox(player.Character, Box3DDrawings[player.Character], Box3DSettings.KillerColor, true)
            end
        end
    end
end

-- æ¸…ç†3Dæ–¹æ¡†
local function cleanup3DBoxes()
    for _, drawing in pairs(Box3DDrawings) do
        if drawing then
            for _, line in pairs(drawing.lines) do
                line:Remove()
            end
        end
    end
    Box3DDrawings = {}
end

-- ä¸»å¼€å…³
Visual:AddToggle("Box3DToggle", {
    Text = "å¯ç”¨3Dæ–¹æ¡†",
    Default = false,
    Callback = function(enabled)
        Box3DSettings.Enabled = enabled
        if enabled then
            -- åˆå§‹åŒ–è¿æ¥
            if not Box3DSettings.connection then
                Box3DSettings.connection = game:GetService("RunService").RenderStepped:Connect(update3DBoxes)
            end
            
            -- ç›‘å¬è§’è‰²ç§»é™¤
            if not Box3DSettings.removedConnection then
                Box3DSettings.removedConnection = workspace.DescendantRemoving:Connect(function(descendant)
                    if Box3DDrawings[descendant] then
                        for _, line in pairs(Box3DDrawings[descendant].lines) do
                            line:Remove()
                        end
                        Box3DDrawings[descendant] = nil
                    end
                end)
            end
        else
            -- å…³é—­è¿æ¥
            if Box3DSettings.connection then
                Box3DSettings.connection:Disconnect()
                Box3DSettings.connection = nil
            end
            
            if Box3DSettings.removedConnection then
                Box3DSettings.removedConnection:Disconnect()
                Box3DSettings.removedConnection = nil
            end
            
            -- æ¸…ç†ç»˜åˆ¶å¯¹è±¡
            cleanup3DBoxes()
        end
    end
})
